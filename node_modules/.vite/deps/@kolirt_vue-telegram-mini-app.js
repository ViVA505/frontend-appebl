import {
  reactive
} from "./chunk-U3LI7FBV.js";

// node_modules/@kolirt/vue-telegram-mini-app/dist/vue-telegram-mini-app.js
var t = window.Telegram.WebApp;
function c(e) {
  return t.isVersionAtLeast(e);
}
function B(e) {
  t.BackButton.onClick(e);
}
function P(e) {
  t.BackButton.offClick(e);
}
var r = reactive({
  initData: "",
  // initDataUnsafe
  version: "",
  platform: "",
  colorScheme: "",
  // themeParams
  isExpanded: false,
  viewportHeight: 0,
  viewportStableHeight: 0,
  headerColor: "",
  backgroundColor: "",
  isClosingConfirmationEnabled: false,
  isVerticalSwipesEnabled: false
});
function a() {
  r.initData = t.initData, r.version = t.version, r.platform = t.platform, r.colorScheme = t.colorScheme, r.isExpanded = t.isExpanded, r.viewportHeight = t.viewportHeight, r.viewportStableHeight = t.viewportStableHeight, r.headerColor = t.headerColor, r.backgroundColor = t.backgroundColor, r.isClosingConfirmationEnabled = t.isClosingConfirmationEnabled, r.isVerticalSwipesEnabled = t.isVerticalSwipesEnabled;
}
function O() {
  t.BackButton.show(), a();
}
function E() {
  t.BackButton.hide(), a();
}
function I() {
  return c("6.1");
}
var X = Object.freeze(Object.defineProperty({
  __proto__: null,
  hide: E,
  isSupported: I,
  offClick: P,
  onClick: B,
  show: O
}, Symbol.toStringTag, { value: "Module" }));
function $() {
  return c("6.1");
}
function p(e) {
  t.setBackgroundColor(e), a();
}
var Z = Object.freeze(Object.defineProperty({
  __proto__: null,
  isSupported: $,
  set: p
}, Symbol.toStringTag, { value: "Module" }));
function j() {
  return c("6.2");
}
function m() {
  t.enableClosingConfirmation(), a();
}
function M() {
  t.disableClosingConfirmation(), a();
}
var ee = Object.freeze(Object.defineProperty({
  __proto__: null,
  disable: M,
  enable: m,
  isSupported: j
}, Symbol.toStringTag, { value: "Module" }));
function H(e) {
  return new Promise((i, o) => {
    t.CloudStorage.getItem(e, function(n, l) {
      n && o(n), i(l);
    });
  });
}
function A(e) {
  return new Promise((i, o) => {
    t.CloudStorage.getItems(e, function(n, l) {
      n && o(n), i(l);
    });
  });
}
function L() {
  return new Promise((e, i) => {
    t.CloudStorage.getKeys(function(o, n) {
      o && i(o), e(n);
    });
  });
}
function R(e) {
  return new Promise((i, o) => {
    t.CloudStorage.removeItem(e, function(n) {
      n && o(n), i();
    });
  });
}
function V(e) {
  return new Promise((i, o) => {
    t.CloudStorage.removeItem(e, function(n) {
      n && o(n), i();
    });
  });
}
function z(e, i) {
  return new Promise((o, n) => {
    t.CloudStorage.setItem(e, i, function(l) {
      l && n(l), o();
    });
  });
}
function q() {
  return c("6.9");
}
var te = Object.freeze(Object.defineProperty({
  __proto__: null,
  getItem: H,
  getItems: A,
  getKeys: L,
  isSupported: q,
  removeItem: R,
  removeItems: V,
  setItem: z
}, Symbol.toStringTag, { value: "Module" }));
var D = ((e) => (e.ThemeChanged = "themeChanged", e.ViewportChanged = "viewportChanged", e.MainButtonClicked = "mainButtonClicked", e.BackButtonClicked = "backButtonClicked", e.SettingsButtonClicked = "settingsButtonClicked", e.InvoiceClosed = "invoiceClosed", e.PopupClosed = "popupClosed", e.QrTextReceived = "qrTextReceived", e.ClipboardTextReceived = "clipboardTextReceived", e.WriteAccessRequested = "writeAccessRequested", e.ContactRequested = "contactRequested", e.BiometricManagerUpdated = "biometricManagerUpdated", e.BiometricAuthRequested = "biometricAuthRequested", e.BiometricTokenUpdated = "biometricTokenUpdated", e))(D || {});
var b = reactive({
  autoExpandInterval: 1e3
});
function F(e) {
  "autoExpandInterval" in e && (b.autoExpandInterval = e.autoExpandInterval), e.alwaysExpand && w(), e.closingConfirmation && m(), e.headerColor && S(e.headerColor), e.backgroundColor && p(e.backgroundColor);
}
var g;
function C() {
  t.expand(), a();
}
function w() {
  g = setInterval(() => {
    t.isExpanded || C();
  }, b.autoExpandInterval);
}
function U() {
  clearInterval(g);
}
var oe = Object.freeze(Object.defineProperty({
  __proto__: null,
  disableAutoExpand: U,
  enableAutoExpand: w,
  index: C
}, Symbol.toStringTag, { value: "Module" }));
function Y(e = "medium") {
  t.HapticFeedback.impactOccurred(e);
}
function K(e = "success") {
  t.HapticFeedback.notificationOccurred(e);
}
function W() {
  t.HapticFeedback.selectionChanged();
}
function Q() {
  return c("6.1");
}
var ne = Object.freeze(Object.defineProperty({
  __proto__: null,
  impactOccurred: Y,
  isSupported: Q,
  notificationOccurred: K,
  selectionChanged: W
}, Symbol.toStringTag, { value: "Module" }));
function G() {
  return c("6.1");
}
function S(e) {
  t.setHeaderColor(e), a();
}
var ie = Object.freeze(Object.defineProperty({
  __proto__: null,
  isSupported: G,
  set: S
}, Symbol.toStringTag, { value: "Module" }));
function u() {
  return c("7.7");
}
function v() {
  t.enableVerticalSwipes(), a();
}
function h() {
  t.disableVerticalSwipes(), a();
}
var re = Object.freeze(Object.defineProperty({
  __proto__: null,
  disable: h,
  enable: v,
  isSupported: u
}, Symbol.toStringTag, { value: "Module" }));
function ae() {
  t.close();
}
function ce() {
  t.ready(), a();
}
function x(e) {
  let i = 0, o = false;
  return function(n) {
    clearTimeout(i), o ? (n.preventDefault(), o = false) : (o = true, i = setTimeout(() => {
      o = false;
    }, e));
  };
}
function le(e = 500) {
  document.body.addEventListener("touchstart", x(e), { passive: false });
}
function de(e = 500) {
  document.body.removeEventListener("touchstart", x(e));
}
var s = { passive: false };
var _;
var d;
function T(e) {
  _ = e.touches[0].clientY;
}
function k(e) {
  if (d) {
    const i = d.scrollTop, o = e.changedTouches[0].clientY;
    i <= 0 && _ < o && e.preventDefault();
  } else
    e.preventDefault();
}
function y() {
  window.scrollY !== window.overflowPadding && window.scrollTo(0, window.overflowPadding);
}
function ue(e) {
  u() ? h() : (d = e, window.overflowPadding = 100, document.body.style.height = window.innerHeight + window.overflowPadding + "px", window.scrollTo(0, window.overflowPadding), window.addEventListener("scroll", y), document.documentElement.addEventListener("touchstart", T, s), document.documentElement.addEventListener("touchmove", k, s));
}
function se() {
  u() ? v() : (window.removeEventListener("scroll", y), document.documentElement.removeEventListener("touchstart", T), document.documentElement.removeEventListener("touchmove", k));
}
function J() {
  a();
}
function fe(e = {}) {
  return {
    install() {
      F(e), J();
    }
  };
}
export {
  X as BackButton,
  Z as BackgroundColor,
  ee as ClosingConfirmation,
  te as CloudStorage,
  D as Events,
  oe as Expand,
  ne as HapticFeedback,
  ie as HeaderColor,
  re as VerticalSwipes,
  ae as close,
  fe as createTelegramMiniApp,
  le as fixIosMultitaps,
  ue as fixTma,
  c as isVersionAtLeast,
  ce as ready,
  r as state,
  de as unfixIosMultitaps,
  se as unfixTma,
  a as updateState,
  t as webApp
};
//# sourceMappingURL=@kolirt_vue-telegram-mini-app.js.map
